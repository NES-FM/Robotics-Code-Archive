#pragma config(Sensor, S1,     HTCSL,          sensorI2CCustom)//links
#pragma config(Sensor, S2,     centerL,      sensorLightActive)//mitte
#pragma config(Sensor, S3,     HTCSR,          sensorI2CCustom)//rechts
#pragma config(Sensor, S4,     mux,            sensorI2CCustom)
#pragma config(Motor,  motorA,          g,             tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          r,             tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          l,             tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/***********************************************************************
*
*  Name:				roboDF_4.c
*
*  Funktion:    Mit Drei sensoren der linie folgen und baelle aus dem Raum retten
*
*  Version:			4.0
*
*  Author:			Florian Magg
*
************************************************************************/

#include "dInclude.h" //includet alle 3d party treiber
#include "drivers/move.h" //move(int motorl,int motorr,int step,int time)
#include "config_4.h" //alle configs
#include "roboDF_4.h" //alle funktionen

task getValues(); //liest die Werte aus
task debugOutput(); //gibt einen Output auf dem Display
void raum(); //das Raumprogramm

bool raumAuschaltenAktivieren = true;

task main()
{
	StartTask(getValues); //startet den werte-task
	delay(500); //laesst die sensoren sich initialisieren
	if(debug) //startet den debug task, wenn debug aktiviert ist
		StartTask(debugOutput);

	if(vMux[IRFront]>700) //wenn der greifer offen ist, wird er zu gemacht
	{
		raGreiferZustand = auf;
		greifer(zu);
	}

	while(true) //unendliche while schleife
	{

		if(raumAuschaltenAktivieren == true && (schwarzLinks() || schwarzRechts()))
		{
			raumActive = false;
			raumAuschaltenAktivieren = false;
		}
		//wenn links und mitte schwarz-----------------------------------
		if(schwarzLinks() && istCenterAufLinie() && !schwarzRechts())
		{
			lastState = "ld90";
			log_WDS("ld90i");
			move(15,15,0,300);
			linksDrehenS();
			log_WDS("ld90o");
			delay(10);
		}

		//wenn links schwarz---------------------------------------------
		if(schwarzLinks() && !istCenterAufLinie() && !schwarzRechts())
		{
			lastState = "ldm";
			linksDrehenM();
			log_WDS("ldm");
			delay(10);
		}

		//wenn mitte schwarz---------------------------------------------
		if(istCenterAufLinie())
		{
			lastState = "g";
			geradeausfahren();
			log_WDS("g");
			delay(10);
		}

		//wenn mitte und rechts schwarz----------------------------------
		if(!schwarzLinks() && istCenterAufLinie() && schwarzRechts())
		{
			lastState = "rd90";
			log_WDS("rd90i");
			move(15,15,0,300);
			rechtsDrehenS();
			log_WDS("rd90o");
			delay(10);
		}

		//wenn rechts schwarz--------------------------------------------
		if(!schwarzLinks() && !istCenterAufLinie() && schwarzRechts())
		{
			lastState = "rdm";
			rechtsDrehenM();
			log_WDS("rdm");
			delay(10);
		}

		//wenn alle schwarz (kreuzung)
		if(schwarzLinks()&&istCenterAufLinie()&&schwarzRechts())
		{
			geradeausfahren();
			while(schwarzLinks()||schwarzRechts()) {}
			move(normGeschw,normGeschw,90);
			NZGrad(rechts); //hier die abbiege-richtung einstellen
			move(-normGeschw,-normGeschw,65);
			geradeausfahren();
		}

		//wenn Ein touch gedrueckt ist
		if(vMux[Touch]>Tpress)
		{
			log_WDS("ausw");
			StopTask(getValues);
			ausweichen();
			StartTask(getValues);
			delay(300);
		}

		//wenn der raum aktiv ist und die sensoren den richtigen wert liefern
		if(raumActive == true && raumEntry())
		{
			raum();
			PlaySound(soundLowBuzz);
		}

		//wenn der roboter flach ist
		if(vMux[Accel] > accel_flat_min && vMux[Accel] < accel_flat_max && lastAccel != "forward")
		{
			drehenMPos = drehenMPosStandard;
			drehenSPos = drehenSPosStandard;
			drehenMNeg = drehenMNegStandard;
			drehenSNeg = drehenSNegStandard;

			raumActive = true;
			lastAccel = "forward";
		}

		//wenn der roboter die Rampe runter faehrt
		if(vMux[Accel] < accel_ramp_down && lastAccel != "ramp_down")
		{
			drehenMPos = drehenMPosR;
			drehenSPos = drehenSPosR;
			drehenMNeg = drehenMNegR;
			drehenSNeg = drehenSNegR;

			raumActive = true;
			lastAccel = "ramp_down";
		}

		//wenn der roboter die Rampe hoch faehrt
		if(vMux[Accel] > accel_ramp_up && lastAccel != "ramp_up")
		{
			drehenMPos = drehenMPosR;
			drehenSPos = drehenSPosR;
			drehenMNeg = drehenMNegR;
			drehenSNeg = drehenSNegR;

			raumActive = false;
			lastAccel = "ramp_up";
		}

	}//end: while(true)
} //end: task main()

task getValues()
{
	while(true)
	{
		HTCSreadRGB(HTCSL, redL, greenL, blueL);
		HTCSreadRGB(HTCSR, redR, greenR, blueR);
		vMux[0] = LSvalRaw(port1);
		vMux[1] = LSvalRaw(port2);
		vMux[2] = LSvalRaw(port3);
		HTACreadAllAxes(port4, _x_axis, _y_axis, _z_axis);
		vMux[3] = _x_axis;
		readColor();
	} //end: while(true)
} //end: task getValues()

//debug-zeilen: 4,5,6,7
task debugOutput()
{
	while(true)
	{
		nxtDisplayCenteredTextLine(4,"Side IR: %d",vMux[IRSide]);
		nxtDisplayCenteredTextLine(5,"Front IR: %d",vMux[IRFront]);
		nxtDisplayCenteredTextLine(6,"Accel_x: %d",vMux[Accel]);
		nxtDisplayCenteredTextLine(7,"light: %d",SensorValue[centerL]);
		//-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-\\
		delay(500);
	} //end: while(true)
} //end: task debugOutput()

/**********************************************
*
* Richtung: false = vom startpunkt weg
* true =  zum startpunkt hin
*  ________________________________________
* |  /				   											  \  |
* |2/				     												 \3|
* |/				 												      \|
* |																         |
* |\				  											      /|
* |1\				                             /4|
* |__\__________________________________/__|
*
***********************************************/


void raum()
{
	PlaySound(soundLowBuzz);

	//merkt sich die ausgangsposition um spaeter zurueck zu fahren
	nMotorEncoder[motorB] = 0;
	geradeausfahren();
	while(!schwarzLinks()&&!istCenterAufLinie()&&!schwarzRechts()&&vMux[Touch]<Tpress) {}
	if(vMux[Touch]>Tpress) //wenn die taster gedrueckt sind, ist es der Raum ...
	{
		move(-(normGeschw + 10),-(normGeschw + 10),(nMotorEncoder[motorB] - 550));
	}
	else //... sonst die linie
		return;

	//move(normGeschw,normGeschw,600);



	NZGrad(links); //dreht sich um zu messen, an welcher seite er rein-gefahren ist

	if(vMux[IRSide]<raIRKL) //lange seite reingefahren
	{
		raEcken[0] = 1;
		raEcken[1] = 2;
		raEcken[2] = 3;
		raEcken[3] = 4;
		nxtDisplayCenteredTextLine(0,"LANGE S. Reing.");
	}
	else //kurze seite reingefahren
	{
		raEcken[0] = 4;
		raEcken[1] = 1;
		raEcken[2] = 2;
		raEcken[3] = 3;
		nxtDisplayCenteredTextLine(0,"KURZE S. Reing.");
	}

	move(-normGeschw,normGeschw,75);
	greifer(auf);

	int i = 0;
	while(kachelEcke==99)//i<3&&
	{
		geradeausfahren();
		while(vMux[Touch]<Tpress)//&&vMux[TouchR]<Tpress
		{
			if(istCenterAufLinie())
			{
				PlaySound(soundUpwardTones);
				kachelEcke = raEcken[i];
				if(raBall)
				{
					greifer(auf);
				}
				break;
			}
			if(vMux[IRFront]<raBallIrDrinnen)
			{
				raBall = true;
				greifer(zu);
			}
		}
		if(kachelEcke==99)
		{
			PlaySound(soundDownwardTones);
			NZGrad(rechts);
			//			move(-normGeschw,normGeschw,75);

			i++;
		}
	}
	nxtDisplayCenteredTextLine(1,"KE: %d",kachelEcke);
	if(kachelEcke==1||kachelEcke==3)
	{
		move(-normGeschw,-normGeschw,raBisMitte);
		NZGrad(rechts);
		move(normGeschw,normGeschw,raBisMitte);
		NZGrad(rechts);
		move(-normGeschw,-normGeschw,0,raAusrichten);
		while(true)
		{
			raBallSuchen();
			move(-normGeschw,normGeschw,(NZgradSteps / 2));
			geradeausfahren();
			while(!istCenterAufLinie()) {}
			anhalten();
			greifer(auf);
			raBall = false;
			raRichtung = false;
			move(-normGeschw,-normGeschw,700);
			move(-normGeschw,normGeschw,(NZgradSteps + (NZgradSteps / 2)));
			move(-normGeschw,-normGeschw,0,(raAusrichten * 2));
		}
	}
	//wenn die kachelecke 2 oder 4 ist
	if(kachelEcke==2||kachelEcke==4)
	{
		move(-normGeschw,-normGeschw,raBisMitte);
		NZGrad(rechts);
		move(-normGeschw,-normGeschw,0,raAusrichten);
		while(true)
		{
			raBallSuchen();
			move(normGeschw,-normGeschw,(NZgradSteps / 2));
			geradeausfahren();
			while(!istCenterAufLinie()) {}
			anhalten();
			greifer(auf);
			raBall = false;
			raRichtung = false;
			move(-normGeschw,-normGeschw,500);
			move(normGeschw,-normGeschw,(NZgradSteps + (NZgradSteps / 2)));
			move(-normGeschw,-normGeschw,0,(raAusrichten * 2));
		}
	}//end: if(ke=2||ke=4)

	anhaltenFuer(10000,0,0);

}//end: void raum()
