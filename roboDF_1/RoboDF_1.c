#pragma config(Sensor, S1,     HTCSR,          sensorI2CCustom)
#pragma config(Sensor, S2,     centerL,        sensorLightActive)
#pragma config(Sensor, S3,     HTCSL,          sensorI2CCustom)
#pragma config(Sensor, S4,     HTSMUX,         sensorI2CCustom)
#pragma config(Motor,  motorA,          greifer,       tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          left,          tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,          righ,          tmotorNXT, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//************************************************************************************//
//
//   Name: linie_raum_2
//
//   Funktionen: Fahren, Gegenstand, Raum
//
//   arena werte:  #define minSchwarzGL 5  //Min und max fuer schwarz links:
//								 #define maxSchwarzGL 30
//
//								 #define minSchwarzGR 5  //Min und max fuer schwarz rechts:
//								 #define maxSchwarzGR 35
//
//								 #define maxSchwarz 40  //mittlerer sensor kalibrierung
//								 #define minWeis 45
//   ______      ______     ____       ______                ____   ___________
//  ||  _  |    / ____ \   |  _  \    / ____ \    _______   |  _ \  \____ ____/
//  || |_| /   / |    | \  | |_| /   / |    | \  /       \  | | | \   __| |__
//  ||_____\   | |    | |  |  __ \   | |    | |  \_______/  | | | |   \_   _/
//  ||      \  \ |____| /  | |__| |  \ |____| /             | |_| /     | |
//  ||       \  \______/   |_____/    \______/              |____/      \_/
//
//************************************************************************************//
#include "config.h"
#include "RoboDF.h"

bool aSW = false;

//task werte();
void ballHolen();
task raum();
task main()
{
//	StartTask(werte);
	nVolume = 2;
	while(true)
	{
		if(!schwarzLinks() && istCenterAufLinie() && schwarzRechts())
		{
			while(schwarzRechts())
			{
			}
			delay(75);
			nachRechtsDrehen();
			delay(5);
		}

		if(!schwarzLinks() && !istCenterAufLinie() && schwarzRechts())
		{
			nachRechtsDrehen();
			delay(5);
		}

		if(schwarzLinks() && istCenterAufLinie() && !schwarzRechts())
		{
			while(schwarzLinks())
			{
			}
			nachLinksDrehen();
			delay(5);
		}

		if(schwarzLinks() && !istCenterAufLinie() && !schwarzRechts())
		{
			nachLinksDrehen();
			delay(5);
		}


		if(schwarzLinks() && istCenterAufLinie() && schwarzRechts())
		{
			geradeausFahren();
			while(schwarzLinks() && istCenterAufLinie() && schwarzRechts())
			{
			}
		}

		if(!schwarzLinks() && gruenRechts())
		{
			piepR();
			while(gruenRechts())
			{
			}

			if(schwarzRechts())
			{
				while(schwarzRechts())
				{
				}

				nachRechtsDrehen();

				delay(900);

				while(istCenterAufLinie())
				{
				}

				//			delay(100);

				//			while(schwarzLinks())
				//			{
				//			}
			}
		}

		if(gruenLinks() && !schwarzRechts())
		{
			piepL();

			while(gruenLinks())
			{
			}

			if(schwarzLinks())
			{
				while(schwarzLinks())
				{
				}

				//				delay(750);

				nachLinksDrehen();

				delay(900);

				while(istCenterAufLinie())
				{
				}
			}
		}

		if(LSvalRaw(TouchL) >= 800 || LSvalRaw(TouchR) >= 800)
		{
			PlaySound(soundBeepBeep);

			ausweichen(links);
		}

		if(istCenterAufLinie())
		{
			//			delay(75);
			geradeausFahren();
//			delay(5);
		}
		HTCSreadRGB(HTCSL, redL, greenL, blueL);
		HTCSreadRGB(HTCSR, redR, greenR, blueR);

		if(((redL == 255) && (redR == 255)) && ((greenL == 255) && (greenR == 255)) && ((blueL == 255) && (blueR == 255)))// && greenL >= 50)// && greenL >= 250)
		{
			StartTask(raum);
		}
	}
}






task raum()
{
	StopTask(main);

	move(motorB, raumGeschw - 10, 500);
	move(motorC, raumGeschw, 500);
	while(nMotorRunState[motorB] != runStateIdle) {	}

	move(motorB, raumGeschw, neunzigGrad);
	move(motorC, -raumGeschw, -neunzigGrad);
	while(nMotorRunState[motorB] != runStateIdle) {	}

	geradeausFahrenRaum();

	while(LSvalNorm(TouchL) <= tWert || LSvalNorm(TouchR) <= tWert) { }

	move(motorB, -raumGeschw, -100);
	move(motorC, -raumGeschw, -100);
	while(nMotorRunState[motorB] != runStateIdle) {	}

	move(motorB, -raumGeschw, -neunzigGrad);
	move(motorC, raumGeschw, neunzigGrad);
	while(nMotorRunState[motorB] != runStateIdle) {	}

	geradeausFahrenRaum();

	nVolume = 4;
	while(true)
	{
		PlaySound(soundBlip);
		delay(500);
		while(LSvalNorm(TouchL) <= tWert || LSvalNorm(TouchR) <= tWert)
		{
			if(schwarzRechts())
			{
				kachelEcke = 1;
				PlaySound(soundBeepBeep);
				break;
			}
		}
		if(kachelEcke == NULL)
		{
			PlaySound(soundDownwardTones);
			move(motorB, -raumGeschw, -neunzigGrad);
			move(motorC, raumGeschw, neunzigGrad);
			while(nMotorRunState[motorB] != runStateIdle) {	}
			zurueckFahren();
			delay(2000);
			geradeausFahrenRaum();
			while(LSvalNorm(TouchL) <= tWert || LSvalRaw(TouchR) <= tWert)
			{
				if(schwarzRechts())
				{
					kachelEcke = 2;
					PlaySound(soundBeepBeep);
					break;
				}
			}
			if(kachelEcke == NULL)
			{
				kachelEcke = 3;
			}
		}

		anhalten();
		nxtDisplayCenteredTextLine(3, "%d", kachelEcke);

		if(kachelEcke == 1)
		{
			move(motorB, -raumGeschw, -500);
			move(motorC, -raumGeschw, -500);
			while(nMotorRunState[motorB] != runStateIdle) {	}
			move(motorB, -raumGeschw, -410);
			move(motorC, raumGeschw, 410);
			while(nMotorRunState[motorB] != runStateIdle) {	}
			while(true)
			{
				zurueckFahren();
				delay(2000);
				geradeausFahrenRaum();
				delay(2000);

				irWerte[kachelEcke] = LSvalNorm(RightIR) - 1;

				while(LSvalNorm(TouchL) <= tWert || LSvalNorm(TouchR) <= tWert)
				{
					if(LSvalNorm(RightIR) < irWerte[kachelEcke])
					{
						ballHolen();

						if(richtung == vor)
						{
							move(motorB, -raumGeschw, -neunzigGrad);
							move(motorC, raumGeschw, neunzigGrad);
							while(nMotorRunState[motorB] != runStateIdle) {	}
						}
						else
						{
							move(motorB, raumGeschw, neunzigGrad);
							move(motorC, -raumGeschw, -neunzigGrad);
							while(nMotorRunState[motorB] != runStateIdle) {	}
						}

						geradeausFahrenRaum();
						while(LSvalNorm(TouchL) <= tWert || LSvalNorm(TouchR) <= tWert) { }

						move(motorB, -raumGeschw, -650);
						move(motorC, -raumGeschw, -650);
						while(nMotorRunState[motorB] != runStateIdle) {	}

						move(motorB, raumGeschw, 610);
						move(motorC, -raumGeschw, -610);
						while(nMotorRunState[motorB] != runStateIdle) {	}

						move(motorB, -raumGeschw, -600);
						move(motorC, -raumGeschw, -600);
						while(nMotorRunState[motorB] != runStateIdle) {	}

/*						geradeausFahrenRaum();
						while(!schwarzRechts()) { }

						move(motorB, -raumGeschw, -500);
						move(motorC, -raumGeschw, -500);
						while(nMotorRunState[motorB] != runStateIdle) {	}

						move(motorB, -raumGeschw, -800);
						move(motorC, raumGeschw, 800);
						while(nMotorRunState[motorB] != runStateIdle) {	}

						move(motorB, -raumGeschw, -500);
						move(motorC, -raumGeschw, -500);
						while(nMotorRunState[motorB] != runStateIdle) {	}*/

						move(motorA, -100, -100);
						while(nMotorRunState[motorA] != runStateIdle) {	}
						motor[motorA] = 0;

						move(motorB, -raumGeschw, -200);
						move(motorC, raumGeschw, 200);
						while(nMotorRunState[motorB] != runStateIdle) {	}

						move(motorB, raumGeschw, 500);
						move(motorC, raumGeschw, 500);
						while(nMotorRunState[motorB] != runStateIdle) {	}

						move(motorB, raumGeschw, neunzigGrad);
						move(motorC, -raumGeschw, -neunzigGrad);
						while(nMotorRunState[motorB] != runStateIdle) {	}

						richtung = vor;

						bAndersRum = false;
						zurueckFahren();
						delay(1000);

						break;
					}
				}

				if(bAndersRum)
				{
				zurueckFahren();
				delay(2000);

				move(motorB, raumGeschw, 800);
				move(motorC, -raumGeschw, -800);
				while(nMotorRunState[motorB] != runStateIdle) {	}
				richtung = zurueck;
				}
				else
				{
					bAndersRum = true;
				}
			}
		}

		if(kachelEcke == 2)
		{
			move(motorB, -raumGeschw, -700);
			move(motorC, -raumGeschw, -700);
			while(nMotorRunState[motorB] != runStateIdle) {	}
			move(motorB, raumGeschw, neunzigGrad);
			move(motorC, -raumGeschw, -neunzigGrad);
			while(nMotorRunState[motorB] != runStateIdle) {	}
			move(motorB, -raumGeschw, -600);
			move(motorC, -raumGeschw, -600);
			while(nMotorRunState[motorB] != runStateIdle) {	}
			move(motorB, raumGeschw, neunzigGrad);
			move(motorC, -raumGeschw, -neunzigGrad);
			while(nMotorRunState[motorB] != runStateIdle) {	}
			zurueckFahren();
			delay(4000);
			while(true)
			{
				zurueckFahren();
				delay(2000);
				geradeausFahrenRaum();

				irWerte[kachelEcke] = LSvalNorm(RightIR) - 3;

				while(LSvalNorm(TouchL) <= tWert || LSvalNorm(TouchR) <= tWert)
				{
					if(LSvalNorm(RightIR) < irWerte[kachelEcke])
					{
						ballHolen();

						if(richtung == vor)
						{
							move(motorB, -raumGeschw, -neunzigGrad);
							move(motorC, raumGeschw, neunzigGrad);
							while(nMotorRunState[motorB] != runStateIdle) {	}
						}
						else
						{
							move(motorB, raumGeschw, neunzigGrad);
							move(motorC, -raumGeschw, -neunzigGrad);
							while(nMotorRunState[motorB] != runStateIdle) {	}
						}
						geradeausFahrenRaum();
						while(LSvalNorm(TouchL) <= tWert && LSvalRaw(TouchR) <= tWert) { }

						move(motorB, -raumGeschw, -650);
						move(motorC, -raumGeschw, -650);
						while(nMotorRunState[motorB] != runStateIdle) {	}

						move(motorB, -raumGeschw, -610);
						move(motorC, raumGeschw, 610);
						while(nMotorRunState[motorB] != runStateIdle) {	}

						move(motorB, -raumGeschw, -700);
						move(motorC, -raumGeschw, -700);
						while(nMotorRunState[motorB] != runStateIdle) {	}

/*						geradeausFahrenRaum();
						while(!schwarzRechts()) { }

						move(motorB, -raumGeschw, -500);
						move(motorC, -raumGeschw, -500);
						while(nMotorRunState[motorB] != runStateIdle) {	}

						move(motorB, -raumGeschw, -800);
						move(motorC, raumGeschw, 800);
						while(nMotorRunState[motorB] != runStateIdle) {	}

						move(motorB, -raumGeschw, -500);
						move(motorC, -raumGeschw, -500);
						while(nMotorRunState[motorB] != runStateIdle) {	}*/

						move(motorA, -100, -112);
						while(nMotorRunState[motorA] != runStateIdle) {	}
						motor[motorA] = 0;

						move(motorB, raumGeschw, 200);
						move(motorC, -raumGeschw, -200);
						while(nMotorRunState[motorB] != runStateIdle) {	}

						move(motorB, raumGeschw, 500);
						move(motorC, raumGeschw, 500);
						while(nMotorRunState[motorB] != runStateIdle) {	}

						move(motorB, -raumGeschw, -neunzigGrad);
						move(motorC, raumGeschw, neunzigGrad);
						while(nMotorRunState[motorB] != runStateIdle) {	}

						richtung = vor;

						bAndersRum = false;

						break;
					}

				}
				if(bAndersRum)
				{
				zurueckFahren();
				delay(2000);

				move(motorB, raumGeschw, 800);
				move(motorC, -raumGeschw, -800);
				while(nMotorRunState[motorB] != runStateIdle) {	}
				richtung = zurueck;
				}
				else
				{
					bAndersRum = true;
				}
			}

		}
		if(kachelEcke == 3)
		{
			move(motorB, -raumGeschw, -500);
			move(motorC, -raumGeschw, -500);
			while(nMotorRunState[motorB] != runStateIdle) {	}
			move(motorB, raumGeschw, neunzigGrad);
			move(motorC, -raumGeschw, -neunzigGrad);
			while(nMotorRunState[motorB] != runStateIdle) {	}
			move(motorB, -raumGeschw, -600);
			move(motorC, -raumGeschw, -600);
			while(nMotorRunState[motorB] != runStateIdle) {	}
			move(motorB, raumGeschw, neunzigGrad);
			move(motorC, -raumGeschw, -neunzigGrad);
			while(nMotorRunState[motorB] != runStateIdle) {	}
			zurueckFahren();
			delay(3000);
			while(true)
			{
				zurueckFahren();
				delay(2000);
				geradeausFahrenRaum();
				delay(2000);

				irWerte[kachelEcke] = LSvalNorm(RightIR) - 1;


				while(LSvalNorm(TouchL) <= tWert || LSvalNorm(TouchR) <= tWert)
				{
					if(LSvalNorm(RightIR) < irWerte[kachelEcke])
					{
						writeDebugStreamLine("irWerte: %d, LSvalNorm: %d", irWerte[kachelEcke], LSvalNorm(RightIR));
						ballHolen();

						if(richtung == vor)
						{
							move(motorB, -raumGeschw, -neunzigGrad);
							move(motorC, raumGeschw, neunzigGrad);
							while(nMotorRunState[motorB] != runStateIdle) {	}
						}
						else
						{
							move(motorB, raumGeschw, neunzigGrad);
							move(motorC, -raumGeschw, -neunzigGrad);
							while(nMotorRunState[motorB] != runStateIdle) {	}
						}
						geradeausFahrenRaum();
						while(LSvalNorm(TouchL) <= tWert && LSvalRaw(TouchR) <= tWert) { }

						move(motorB, -raumGeschw, -650);
						move(motorC, -raumGeschw, -650);
						while(nMotorRunState[motorB] != runStateIdle) {	}

						move(motorB, raumGeschw, 610);
						move(motorC, -raumGeschw, -610);
						while(nMotorRunState[motorB] != runStateIdle) {	}

						move(motorB, -raumGeschw, -700);
						move(motorC, -raumGeschw, -700);
						while(nMotorRunState[motorB] != runStateIdle) {	}

/*						geradeausFahrenRaum();
						while(!schwarzRechts()) { }

						move(motorB, -raumGeschw, -500);
						move(motorC, -raumGeschw, -500);
						while(nMotorRunState[motorB] != runStateIdle) {	}

						move(motorB, -raumGeschw, -800);
						move(motorC, raumGeschw, 800);
						while(nMotorRunState[motorB] != runStateIdle) {	}

						move(motorB, -raumGeschw, -500);
						move(motorC, -raumGeschw, -500);
						while(nMotorRunState[motorB] != runStateIdle) {	}*/

						move(motorA, -100, -112);
						while(nMotorRunState[motorA] != runStateIdle) {	}
						motor[motorA] = 0;

						move(motorB, -raumGeschw, -200);
						move(motorC, raumGeschw, 200);
						while(nMotorRunState[motorB] != runStateIdle) {	}

						move(motorB, raumGeschw, 500);
						move(motorC, raumGeschw, 500);
						while(nMotorRunState[motorB] != runStateIdle) {	}

						move(motorB, raumGeschw, neunzigGrad);
						move(motorC, -raumGeschw, -neunzigGrad);
						while(nMotorRunState[motorB] != runStateIdle) {	}

						richtung = vor;

						bAndersRum = false;

						zurueckFahren();
						delay(1000);

						break;
					}

				}
				if(bAndersRum)
				{
				zurueckFahren();
				delay(2000);

				move(motorB, raumGeschw, 800);
				move(motorC, -raumGeschw, -800);
				while(nMotorRunState[motorB] != runStateIdle) {	}
				richtung = zurueck;
				}
				else
				{
					bAndersRum = true;
				}
			}
		}
	}
}

void ballHolen()
{
	PlaySound(soundUpwardTones);

	move(motorB, -raumGeschw, -150);
	move(motorC, -raumGeschw, -150);
	while(nMotorRunState[motorB] != runStateIdle) {	}

	move(motorB, -raumGeschw, -400);
	move(motorC, raumGeschw, 400);
	while(nMotorRunState[motorB] != runStateIdle) {	}

	move(motorB, raumGeschw, 200);
	move(motorC, raumGeschw, 200);
	while(nMotorRunState[motorB] != runStateIdle) {	}

	move(motorA, 10, 112);
	while(nMotorRunState[motorA] != runStateIdle) {	}
	motor[motorA] = 0;

	move(motorB, -20, -raumZurueckFuerBall[kachelEcke]);
	move(motorC, -20, -raumZurueckFuerBall[kachelEcke]);
	while(nMotorRunState[motorB] != runStateIdle) {	}

	move(motorB, iFahrGeschw, 650);
	move(motorC, iFahrGeschw, 650);
	while(nMotorRunState[motorB] != runStateIdle) {	}

	move(motorA, -50, -15);
	while(nMotorRunState[motorA] != runStateIdle) {	}
	motor[motorA] = 0;


}
