#pragma config(Sensor, S1,     HTCSR,          sensorI2CCustom)
#pragma config(Sensor, S2,     centerL,        sensorLightActive)
#pragma config(Sensor, S3,     HTCSL,          sensorI2CCustom)
#pragma config(Sensor, S4,     HTSMUX,         sensorI2CCustom)
#pragma config(Motor,  motorA,          greifer,       tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          righ,          tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          left,          tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//************************************************************************************//
//
//   Name: roboDF
//
//   Funktionen: Fahren, Gegenstand, alle funktionen werden mit RoboDF.h eingebunden, alle sachen die man häufig ändern muss mit config.h
//
//   arena werte:  #define minSchwarzGL 5  //Min und max fuer schwarz links:
//								 #define maxSchwarzGL 30
//
//								 #define minSchwarzGR 5  //Min und max fuer schwarz rechts:
//								 #define maxSchwarzGR 35
//
//								 #define maxSchwarz 40  //mittlerer sensor kalibrierung
//								 #define minWeis 45
//
//
//   _____        _____      _____       ______                 _____   ____________
//  |  _  \\     / ___ \\   |  _  \\    / ____ \\    _______   |  _ \\  \____ ____//
//  | |_| //    / |   | \\  | |_| //   / |    | \\  /       \  | | | \\   __| |___
//  |______\\   | |   | ||  |  __ \\   | |    | ||  \_______/  | | | ||   \_   _//
//  ||      \\  \ |___| //  | |__| ||  \ |____| //             | |_| //     | |_
//  ||       \\  \_____//   |_____//    \______//              |____//      \_//
//
//************************************************************************************//
#include "RoboDF_2.h"
#include "config_2.h"

bool aSW = false;

int messenL, messenR, center = 0;

//task werte();
void ballHolen();
task raum();

task main()
{
	//	StartTask(werte);
	nVolume = volMain;
	while(true)
	{
		writeDebugStreamLine("%d",HTCSreadColor(HTCSL));
		//wenn alle rgb-werte 255(raum)----------------------------------
		HTCSreadRGB(HTCSL, redL, greenL, blueL);
		HTCSreadRGB(HTCSR, redR, greenR, blueR);
		if(raumStart())
		{
			StartTask(raum);
		}//end if(raumStart())


		//wenn mitte und rechts schwarz----------------------------------
		if(!schwarzLinks() && istCenterAufLinie() && schwarzRechts())
		{
			while(schwarzRechts())
			{
			}
			delay(75);
			nachRechtsDrehen();
			//delay(5);
		}//end if(!schwarzLinks() && istCenterAufLinie() && schwarzRechts())

		//wenn rechts schwarz--------------------------------------------
		if(!schwarzLinks() && !istCenterAufLinie() && schwarzRechts())
		{
			nachRechtsDrehen();
			//delay(5);
		}//end if(!schwarzLinks() && !istCenterAufLinie() && schwarzRechts())

		//wenn links und mitte schwarz-----------------------------------
		if(schwarzLinks() && istCenterAufLinie() && !schwarzRechts())
		{
			while(schwarzLinks())
			{
			}
			nachLinksDrehen();
			//delay(5);
		}//end if(schwarzLinks() && istCenterAufLinie() && !schwarzRechts())

		//wenn links schwarz---------------------------------------------
		if(schwarzLinks() && !istCenterAufLinie() && !schwarzRechts())
		{
			nachLinksDrehen();
			//delay(5);
		}//end if(schwarzLinks() && !istCenterAufLinie() && !schwarzRechts())

		//wenn alle schwarz----------------------------------------------
		if(schwarzLinks() && istCenterAufLinie() && schwarzRechts())
		{
			geradeausFahren();
			while(schwarzLinks() && istCenterAufLinie() && schwarzRechts())
			{
			}
		}//end if(schwarzLinks() && istCenterAufLinie() && schwarzRechts())

		//wenn rechts gruen----------------------------------------------
		if(!schwarzLinks() && gruenRechts())
		{
			piepR();
			while(gruenRechts())
			{
			}

			//			if(schwarzRechts())
			//			{
			while(schwarzRechts())
			{
			}

			delay(300);

			nachRechtsDrehen();

			delay(1300);

			while(istCenterAufLinie())
			{
			}

			//			delay(100);

			//			while(schwarzLinks())
			//			{
			//			}
			//			}
		}//end if(!schwarzLinks() && gruenRechts())

		//wenn links gruen-----------------------------------------------
		if(gruenLinks() && !schwarzRechts())
		{
			piepL();

			while(gruenLinks())
			{
			}

			//			if(schwarzLinks())
			//			{
			while(schwarzLinks())
			{
			}

			delay(300);

			nachLinksDrehen();

			delay(1300);

			while(istCenterAufLinie())
			{
			}
			//			}
		}//end if(gruenLinks() && !schwarzRechts())

		//wenn linker oder rechter touch gedrueckt-----------------------
		if(LSvalRaw(TouchL) >= 800 || LSvalRaw(TouchR) >= 800)
		{
			PlaySound(soundBeepBeep);

			ausweichen(links);
		}//end if(LSvalRaw(TouchL) >= 800 || LSvalRaw(TouchR) >= 800)

		//wenn mitte schwarz---------------------------------------------
		if(istCenterAufLinie())
		{
			//			delay(75);
			geradeausFahren();
			//			delay(5);
		}//end if(istCenterAufLinie())

		//wdh:-wenn mitte und rechts schwarz-----------------------------
		if(!schwarzLinks() && istCenterAufLinie() && schwarzRechts())
		{
			while(schwarzRechts())
			{
			}
			delay(75);
			nachRechtsDrehen();
			//delay(5);
		}//end if(!schwarzLinks() && istCenterAufLinie() && schwarzRechts())

		//wdh:-wenn rechts schwarz---------------------------------------
		if(!schwarzLinks() && !istCenterAufLinie() && schwarzRechts())
		{
			nachRechtsDrehen();
			//delay(5);
		}//end if(!schwarzLinks() && !istCenterAufLinie() && schwarzRechts())

		//wdh:-wenn links und mitte schwarz------------------------------
		if(schwarzLinks() && istCenterAufLinie() && !schwarzRechts())
		{
			while(schwarzLinks())
			{
			}
			nachLinksDrehen();
			//delay(5);
		}//end if(schwarzLinks() && istCenterAufLinie() && !schwarzRechts())

		//wdh:-wenn links schwarz----------------------------------------
		if(schwarzLinks() && !istCenterAufLinie() && !schwarzRechts())
		{
			nachLinksDrehen();
			//delay(5);
		}//end if(schwarzLinks() && !istCenterAufLinie() && !schwarzRechts())

		//wenn mitte schwarz---------------------------------------------
		if(istCenterAufLinie())
		{
			//			delay(75);
			geradeausFahren();
			delay(10);
		}//end if(istCenterAufLinie())
		if(LSvalNorm(gyro)>= 50)
		{
			geradeausFahren();
			while(LSvalNorm(gyro)>= 50)
			{
			}
			zurueckFahren();
			delay(200);
		}
		writeDebugStreamLine("d: %d,d: %d", durchschnittr, durchschnittl);
	}//end while(true)
}//end task main()






task raum()
{
	StopTask(main);
	nVolume = volRaum;
	PlaySound(soundBlip);
	delay(500);
	move2m(motorB,400,raumGeschw,motorC,400,raumGeschw);
	messenL = LSvalNorm(LeftIR);
	messenR = LSvalNorm(LeftIR);//RightIR
	//hier steht die if abfrage, welche ecke zuerst kommt usw.
	motor[motorA] = 70;
	delay(700);
	motor[motorA] = 0;
	move2m(motorB,440,raumGeschw,motorC,-440,-raumGeschw);
	geradeausFahrenRaum();
	if(kachelEcke == NULL)
	{
		while(LSvalNorm(TouchL) <= tWert && LSvalNorm(TouchR) <= tWert)
		{
			if(schwarzRechts())
			{
				anhalten();
				kachelEcke = keReihenfolge[0];
				if(ballDrinnen)
				{
					move1m(motorA,155,70);
					ballDrinnen = false;
				}
				move2m(motorB,-400,-raumGeschw,motorC,-400,-raumGeschw);
				move2m(motorB,-430,-raumGeschw,motorC,430,raumGeschw - 20);
				move2m(motorB,850,raumGeschw,motorC,850,raumGeschw);
				move2m(motorB,-430,-raumGeschw,motorC,430,raumGeschw);
				break;
			}
			if(center != 0)//LSvalNorm(CenterIR)
			{
				move1m(motorA,-155,-70);
				ballDrinnen = true;
			}
		}
	}
	if(kachelEcke == NULL)
	{
	}
	if(kachelEcke == NULL)
	{
	}
	if(kachelEcke == NULL)
	{
	}
	if(kachelEcke == 1)
	{
		while(true)
		{
			zurueckFahrenRaum();
			delay(2500);
			geradeausFahrenRaum();
			while(LSvalNorm(TouchL) <= tWert && LSvalNorm(TouchR) <= tWert)
			{

			}
			if(richtung == vor){
				richtung = zurueck;
			}
			if(richtung == zurueck){
				richtung = vor;
			}
			nxtDisplayCenteredTextLine(3,"%d",richtung);
			move2m(motorB,-820,-raumGeschw,motorC,820,raumGeschw);
		}
	}
}
void ballHolen()
{
	PlaySound(soundUpwardTones);

	move(motorB, -raumGeschw, -150);
	move(motorC, -raumGeschw, -150);
	while(nMotorRunState[motorB] != runStateIdle) {	}

	move(motorB, -raumGeschw, -400);
	move(motorC, raumGeschw, 400);
	while(nMotorRunState[motorB] != runStateIdle) {	}

	move(motorB, raumGeschw, 200);
	move(motorC, raumGeschw, 200);
	while(nMotorRunState[motorB] != runStateIdle) {	}

	move(motorA, 10, 112);
	while(nMotorRunState[motorA] != runStateIdle) {	}
	motor[motorA] = 0;

	move(motorB, -20, -raumZurueckFuerBall[kachelEcke]);
	move(motorC, -20, -raumZurueckFuerBall[kachelEcke]);
	while(nMotorRunState[motorB] != runStateIdle) {	}

	move(motorB, iFahrGeschw, 650);
	move(motorC, iFahrGeschw, 650);
	while(nMotorRunState[motorB] != runStateIdle) {	}

	move(motorA, -50, -15);
	while(nMotorRunState[motorA] != runStateIdle) {	}
	motor[motorA] = 0;
}
